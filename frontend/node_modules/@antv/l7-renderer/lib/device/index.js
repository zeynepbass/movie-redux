var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// src/device/index.ts
var device_exports = {};
__export(device_exports, {
  default: () => DeviceRendererService
});
module.exports = __toCommonJS(device_exports);
var import_g_device_api = require("@antv/g-device-api");
var import_inversify = require("inversify");
var import_reflect_metadata = require("reflect-metadata");
var import_DeviceAttribute = __toESM(require("./DeviceAttribute"));
var import_DeviceBuffer = __toESM(require("./DeviceBuffer"));
var import_DeviceElements = __toESM(require("./DeviceElements"));
var import_DeviceFramebuffer = __toESM(require("./DeviceFramebuffer"));
var import_DeviceModel = __toESM(require("./DeviceModel"));
var import_DeviceTexture2D = __toESM(require("./DeviceTexture2D"));
var import_webgl = require("./utils/webgl");
var DeviceRendererService = class {
  constructor() {
    this.uniformBuffers = [];
    this.createModel = (options) => new import_DeviceModel.default(this.device, options);
    this.createAttribute = (options) => new import_DeviceAttribute.default(this.device, options);
    this.createBuffer = (options) => new import_DeviceBuffer.default(this.device, options);
    this.createElements = (options) => new import_DeviceElements.default(this.device, options);
    this.createTexture2D = (options) => new import_DeviceTexture2D.default(this.device, options);
    this.createFramebuffer = (options) => new import_DeviceFramebuffer.default(this.device, options);
    this.useFramebuffer = () => {
    };
    this.clear = () => {
    };
    this.viewport = ({
      // x,
      // y,
      width,
      height
    }) => {
      this.width = width;
      this.height = height;
      this.device.width = width;
      this.device.height = height;
    };
    this.readPixels = () => {
      return new Uint8Array();
    };
    this.getViewportSize = () => {
      return {
        // @ts-ignore
        width: this.device.width,
        // @ts-ignore
        height: this.device.height
      };
    };
    this.getContainer = () => {
      var _a;
      return (_a = this.canvas) == null ? void 0 : _a.parentElement;
    };
    this.getCanvas = () => {
      return this.canvas;
    };
    this.getGLContext = () => {
      return this.device["gl"];
    };
    this.destroy = () => {
      var _a;
      this.canvas = null;
      (_a = this.uniformBuffers) == null ? void 0 : _a.forEach((buffer) => {
        buffer.destroy();
      });
      this.device.destroy();
    };
  }
  async init(canvas, cfg) {
    const { enableWebGPU, shaderCompilerPath } = cfg;
    this.canvas = canvas;
    const deviceContribution = enableWebGPU ? new import_g_device_api.WebGPUDeviceContribution({
      shaderCompilerPath
    }) : new import_g_device_api.WebGLDeviceContribution({
      // Use WebGL2 first and downgrade to WebGL1 if WebGL2 is not supported.
      targets: ["webgl2", "webgl1"],
      onContextLost(e) {
        console.warn("context lost", e);
      },
      onContextCreationError(e) {
        console.warn("context creation error", e);
      },
      onContextRestored(e) {
        console.warn("context restored", e);
      }
    });
    const swapChain = await deviceContribution.createSwapChain(canvas);
    swapChain.configureSwapChain(canvas.width, canvas.height);
    this.device = swapChain.getDevice();
    this.swapChain = swapChain;
    const gl = this.device["gl"];
    this.extensionObject = {
      // @ts-ignore
      OES_texture_float: !(0, import_webgl.isWebGL2)(gl) && this.device["OES_texture_float"]
    };
    const renderTargetTexture = this.device.createTexture({
      format: import_g_device_api.Format.U8_RGBA_RT,
      width: canvas.width,
      height: canvas.height,
      usage: import_g_device_api.TextureUsage.RENDER_TARGET
    });
    this.renderTarget = this.device.createRenderTargetFromTexture(renderTargetTexture);
    this.mainDepthRT = this.device.createRenderTargetFromTexture(
      this.device.createTexture({
        format: import_g_device_api.Format.D24_S8,
        width: canvas.width,
        height: canvas.height,
        usage: import_g_device_api.TextureUsage.RENDER_TARGET
      })
    );
  }
  beginFrame() {
    const onscreenTexture = this.swapChain.getOnscreenTexture();
    this.renderPass = this.device.createRenderPass({
      colorAttachment: [this.renderTarget],
      // colorResolveTo: [onscreen ? onscreenTexture : onscreenTexture],
      colorResolveTo: [onscreenTexture],
      colorClearColor: [import_g_device_api.TransparentBlack],
      depthStencilAttachment: this.mainDepthRT,
      depthClearValue: 1
    });
    this.device.renderPass = this.renderPass;
  }
  endFrame() {
    this.device.submitPass(this.renderPass);
  }
  getPointSizeRange() {
    const gl = this.device["gl"];
    return gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
  }
  testExtension(name) {
    return !!this.getGLContext().getExtension(name);
  }
  // TODO: 临时方法
  setState() {
  }
  setBaseState() {
  }
  setCustomLayerDefaults() {
  }
  setDirty(flag) {
    this.isDirty = flag;
  }
  getDirty() {
    return this.isDirty;
  }
};
DeviceRendererService = __decorateClass([
  (0, import_inversify.injectable)()
], DeviceRendererService);
