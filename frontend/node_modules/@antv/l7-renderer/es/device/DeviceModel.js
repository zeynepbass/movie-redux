import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { BlendFactor, BlendMode, ChannelWriteMask, CompareFunction, CullMode, Format, TransparentBlack, VertexStepMode } from '@antv/g-device-api';
import { gl } from '@antv/l7-core';
import { lodashUtil } from '@antv/l7-utils';
import { blendEquationMap, blendFuncMap, cullFaceMap, depthFuncMap, primitiveMap, sizeFormatMap } from "./constants";
var isPlainObject = lodashUtil.isPlainObject,
  isTypedArray = lodashUtil.isTypedArray;
var DeviceModel = /*#__PURE__*/function () {
  function DeviceModel(device, options) {
    var _this = this;
    _classCallCheck(this, DeviceModel);
    _defineProperty(this, "destroyed", false);
    _defineProperty(this, "uniforms", {});
    _defineProperty(this, "vertexBuffers", []);
    this.device = device;
    this.options = options;
    var vs = options.vs,
      fs = options.fs,
      attributes = options.attributes,
      uniforms = options.uniforms,
      count = options.count,
      elements = options.elements;
    this.options = options;
    var program = device.createProgram({
      vertex: {
        glsl: vs
      },
      fragment: {
        glsl: fs
      }
    });
    this.program = program;
    if (uniforms) {
      this.uniforms = this.extractUniforms(uniforms);
    }
    var vertexBufferDescriptors = [];

    // Infer count from data if not provided.
    var inferredCount = 0;
    Object.keys(attributes).forEach(function (name) {
      var attribute = attributes[name];
      var buffer = attribute.get();
      // Bind at each frame.
      _this.vertexBuffers.push(buffer.get());
      var _attribute$attribute = attribute['attribute'],
        _attribute$attribute$ = _attribute$attribute.offset,
        offset = _attribute$attribute$ === void 0 ? 0 : _attribute$attribute$,
        _attribute$attribute$2 = _attribute$attribute.stride,
        stride = _attribute$attribute$2 === void 0 ? 0 : _attribute$attribute$2,
        _attribute$attribute$3 = _attribute$attribute.size,
        size = _attribute$attribute$3 === void 0 ? 1 : _attribute$attribute$3,
        _attribute$attribute$4 = _attribute$attribute.divisor,
        divisor = _attribute$attribute$4 === void 0 ? 0 : _attribute$attribute$4,
        _attribute$attribute$5 = _attribute$attribute.shaderLocation,
        shaderLocation = _attribute$attribute$5 === void 0 ? 0 : _attribute$attribute$5;
      vertexBufferDescriptors.push({
        arrayStride: stride || size * 4,
        // TODO: L7 hasn't use instanced array for now.
        stepMode: VertexStepMode.VERTEX,
        attributes: [{
          format: sizeFormatMap[size],
          shaderLocation: shaderLocation,
          offset: offset,
          divisor: divisor
        }]
      });
      inferredCount = buffer['size'] / size;
    });
    if (!count) {
      this.options.count = inferredCount;
    }
    if (elements) {
      this.indexBuffer = elements.get();
    }
    var inputLayout = device.createInputLayout({
      vertexBufferDescriptors: vertexBufferDescriptors,
      indexBufferFormat: elements ? Format.U32_R : null,
      program: program
    });
    this.inputLayout = inputLayout;
    this.pipeline = this.createPipeline(options);
  }
  _createClass(DeviceModel, [{
    key: "createPipeline",
    value: function createPipeline(options) {
      var _options$primitive = options.primitive,
        primitive = _options$primitive === void 0 ? gl.TRIANGLES : _options$primitive,
        depth = options.depth,
        cull = options.cull,
        blend = options.blend;
      var depthParams = this.initDepthDrawParams({
        depth: depth
      });
      var depthEnabled = !!(depthParams && depthParams.enable);
      var cullParams = this.initCullDrawParams({
        cull: cull
      });
      var cullEnabled = !!(cullParams && cullParams.enable);
      var blendParams = this.getBlendDrawParams({
        blend: blend
      });
      var blendEnabled = !!(blendParams && blendParams.enable);
      return this.device.createRenderPipeline({
        inputLayout: this.inputLayout,
        program: this.program,
        topology: primitiveMap[primitive],
        colorAttachmentFormats: [Format.U8_RGBA_RT],
        depthStencilAttachmentFormat: Format.D24_S8,
        megaStateDescriptor: {
          attachmentsState: [{
            channelWriteMask: ChannelWriteMask.ALL,
            rgbBlendState: {
              blendMode: blendEnabled && blendParams.equation.rgb || BlendMode.ADD,
              blendSrcFactor: blendEnabled && blendParams.func.srcRGB || BlendFactor.SRC_ALPHA,
              blendDstFactor: blendEnabled && blendParams.func.dstRGB || BlendFactor.ONE_MINUS_SRC_ALPHA
            },
            alphaBlendState: {
              blendMode: blendEnabled && blendParams.equation.alpha || BlendMode.ADD,
              blendSrcFactor: blendEnabled && blendParams.func.srcAlpha || BlendFactor.ONE,
              blendDstFactor: blendEnabled && blendParams.func.dstAlpha || BlendFactor.ONE_MINUS_SRC_ALPHA
            }
          }],
          blendConstant: TransparentBlack,
          depthWrite: depthEnabled,
          depthCompare: depthEnabled && depthParams.func || CompareFunction.LESS,
          cullMode: cullEnabled && cullParams.face || CullMode.NONE,
          stencilWrite: false
        }
      });
    }
  }, {
    key: "updateAttributesAndElements",
    value: function updateAttributesAndElements()
    // elements: IElements, // attributes: { [key: string]: IAttribute },
    {
      // TODO: implement
    }
  }, {
    key: "updateAttributes",
    value: function updateAttributes() {// attributes: { [key: string]: IAttribute }
      // TODO: implement
      // Object.keys(attributes).forEach((name: string) => {
      //   const attribute = attributes[name] as DeviceAttribute;
      //   attribute.updateBuffer();
      // });
    }
  }, {
    key: "addUniforms",
    value: function addUniforms(uniforms) {
      this.uniforms = _objectSpread(_objectSpread({}, this.uniforms), this.extractUniforms(uniforms));
    }
  }, {
    key: "draw",
    value: function draw(options
    //  pick?: boolean
    ) {
      var mergedOptions = _objectSpread(_objectSpread({}, this.options), options);
      var _mergedOptions$count = mergedOptions.count,
        count = _mergedOptions$count === void 0 ? 0 : _mergedOptions$count,
        instances = mergedOptions.instances,
        elements = mergedOptions.elements,
        _mergedOptions$unifor = mergedOptions.uniforms,
        uniforms = _mergedOptions$unifor === void 0 ? {} : _mergedOptions$unifor,
        uniformBuffers = mergedOptions.uniformBuffers,
        textures = mergedOptions.textures;
      this.uniforms = _objectSpread(_objectSpread({}, this.uniforms), this.extractUniforms(uniforms));

      // @ts-ignore
      var _this$device = this.device,
        width = _this$device.width,
        height = _this$device.height;

      // @ts-ignore
      // const renderTarget = this.device.currentFramebuffer;
      // const { onscreen } = renderTarget

      // @ts-ignore
      var renderPass = this.device.renderPass;
      // TODO: Recreate pipeline only when blend / cull changed.
      this.pipeline = this.createPipeline(mergedOptions);
      renderPass.setPipeline(this.pipeline);
      renderPass.setVertexInput(this.inputLayout, this.vertexBuffers.map(function (buffer) {
        return {
          buffer: buffer
        };
      }), elements ? {
        buffer: this.indexBuffer,
        offset: 0 // TODO: use defaule value
      } : null);
      renderPass.setViewport(0, 0, width, height);
      if (uniformBuffers) {
        this.bindings = this.device.createBindings({
          pipeline: this.pipeline,
          uniformBufferBindings: uniformBuffers.map(function (uniformBuffer, i) {
            var buffer = uniformBuffer;
            return {
              binding: i,
              buffer: buffer.get(),
              size: buffer['size']
            };
          }),
          samplerBindings: textures === null || textures === void 0 ? void 0 : textures.map(function (t) {
            return {
              texture: t['texture'],
              sampler: t['sampler']
            };
          })
        });
      }
      if (this.bindings) {
        renderPass.setBindings(this.bindings);
        // Compatible to WebGL1.
        this.program.setUniformsLegacy(this.uniforms);
      }
      if (elements) {
        var indexCount = elements['count'];
        if (indexCount === 0) {
          renderPass.draw(count, instances);
        } else {
          renderPass.drawIndexed(indexCount, instances);
        }
      } else {
        renderPass.draw(count, instances);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this$vertexBuffers, _this$indexBuffer, _this$bindings;
      this.program.destroy();
      (_this$vertexBuffers = this.vertexBuffers) === null || _this$vertexBuffers === void 0 || _this$vertexBuffers.forEach(function (buffer) {
        return buffer.destroy();
      });
      (_this$indexBuffer = this.indexBuffer) === null || _this$indexBuffer === void 0 || _this$indexBuffer.destroy();
      (_this$bindings = this.bindings) === null || _this$bindings === void 0 || _this$bindings.destroy();
      this.inputLayout.destroy();
      this.pipeline.destroy();
      this.destroyed = true;
    }
  }, {
    key: "initDepthDrawParams",
    value: function initDepthDrawParams(_ref) {
      var depth = _ref.depth;
      if (depth) {
        return {
          enable: depth.enable === undefined ? true : !!depth.enable,
          mask: depth.mask === undefined ? true : !!depth.mask,
          func: depthFuncMap[depth.func || gl.LESS],
          range: depth.range || [0, 1]
        };
      }
    }
  }, {
    key: "getBlendDrawParams",
    value: function getBlendDrawParams(_ref2) {
      var blend = _ref2.blend;
      var _ref3 = blend || {},
        enable = _ref3.enable,
        func = _ref3.func,
        equation = _ref3.equation,
        _ref3$color = _ref3.color,
        color = _ref3$color === void 0 ? [0, 0, 0, 0] : _ref3$color;
      return {
        enable: !!enable,
        func: {
          srcRGB: blendFuncMap[func && func.srcRGB || gl.SRC_ALPHA],
          srcAlpha: blendFuncMap[func && func.srcAlpha || gl.SRC_ALPHA],
          dstRGB: blendFuncMap[func && func.dstRGB || gl.ONE_MINUS_SRC_ALPHA],
          dstAlpha: blendFuncMap[func && func.dstAlpha || gl.ONE_MINUS_SRC_ALPHA]
        },
        equation: {
          rgb: blendEquationMap[equation && equation.rgb || gl.FUNC_ADD],
          alpha: blendEquationMap[equation && equation.alpha || gl.FUNC_ADD]
        },
        color: color
      };
    }

    // /**
    //  * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#stencil
    //  */
    // private getStencilDrawParams({
    //   stencil,
    // }: Pick<IModelInitializationOptions, 'stencil'>) {
    //   const {
    //     enable,
    //     mask = -1,
    //     func = {
    //       cmp: gl.ALWAYS,
    //       ref: 0,
    //       mask: -1,
    //     },
    //     opFront = {
    //       fail: gl.KEEP,
    //       zfail: gl.KEEP,
    //       zpass: gl.KEEP,
    //     },
    //     opBack = {
    //       fail: gl.KEEP,
    //       zfail: gl.KEEP,
    //       zpass: gl.KEEP,
    //     },
    //   } = stencil || {};
    //   return {
    //     enable: !!enable,
    //     mask,
    //     func: {
    //       ...func,
    //       cmp: stencilFuncMap[func.cmp],
    //     },
    //     opFront: {
    //       fail: stencilOpMap[opFront.fail],
    //       zfail: stencilOpMap[opFront.zfail],
    //       zpass: stencilOpMap[opFront.zpass],
    //     },
    //     opBack: {
    //       fail: stencilOpMap[opBack.fail],
    //       zfail: stencilOpMap[opBack.zfail],
    //       zpass: stencilOpMap[opBack.zpass],
    //     },
    //   };
    // }

    // private getColorMaskDrawParams(
    //   { stencil }: Pick<IModelInitializationOptions, 'stencil'>,
    //   pick: boolean,
    // ) {
    //   // TODO: 重构相关参数
    //   // 掩膜模式下，颜色通道全部关闭
    //   const colorMask =
    //     stencil?.enable && stencil.opFront && !pick
    //       ? [false, false, false, false]
    //       : [true, true, true, true]; // 非掩码模式下，颜色通道全部开启
    //   return colorMask;
    // }

    /**
     * @see https://github.com/regl-project/regl/blob/gh-pages/API.md#culling
     */
  }, {
    key: "initCullDrawParams",
    value: function initCullDrawParams(_ref4) {
      var cull = _ref4.cull;
      if (cull) {
        var enable = cull.enable,
          _cull$face = cull.face,
          face = _cull$face === void 0 ? gl.BACK : _cull$face;
        return {
          enable: !!enable,
          face: cullFaceMap[face]
        };
      }
    }

    /**
     * 考虑结构体命名, eg:
     * a: { b: 1 }  ->  'a.b'
     * a: [ { b: 1 } ] -> 'a[0].b'
     */
  }, {
    key: "extractUniforms",
    value: function extractUniforms(uniforms) {
      var _this2 = this;
      var extractedUniforms = {};
      Object.keys(uniforms).forEach(function (uniformName) {
        _this2.extractUniformsRecursively(uniformName, uniforms[uniformName], extractedUniforms, '');
      });
      return extractedUniforms;
    }
  }, {
    key: "extractUniformsRecursively",
    value: function extractUniformsRecursively(uniformName, uniformValue, uniforms, prefix) {
      var _this3 = this;
      if (uniformValue === null || typeof uniformValue === 'number' ||
      // u_A: 1
      typeof uniformValue === 'boolean' ||
      // u_A: false
      Array.isArray(uniformValue) && typeof uniformValue[0] === 'number' ||
      // u_A: [1, 2, 3]
      isTypedArray(uniformValue) ||
      // u_A: Float32Array
      // @ts-ignore
      uniformValue === '' || 'resize' in uniformValue) {
        uniforms["".concat(prefix && prefix + '.').concat(uniformName)] = uniformValue;
        return;
      }

      // u_Struct.a.b.c
      if (isPlainObject(uniformValue)) {
        Object.keys(uniformValue).forEach(function (childName) {
          _this3.extractUniformsRecursively(childName,
          // @ts-ignore
          uniformValue[childName], uniforms, "".concat(prefix && prefix + '.').concat(uniformName));
        });
      }

      // u_Struct[0].a
      if (Array.isArray(uniformValue)) {
        uniformValue.forEach(function (child, idx) {
          Object.keys(child).forEach(function (childName) {
            _this3.extractUniformsRecursively(childName,
            // @ts-ignore
            child[childName], uniforms, "".concat(prefix && prefix + '.').concat(uniformName, "[").concat(idx, "]"));
          });
        });
      }
    }
  }]);
  return DeviceModel;
}();
export { DeviceModel as default };