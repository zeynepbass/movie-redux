import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
var _dec, _class;
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { Format, TextureUsage, TransparentBlack, WebGLDeviceContribution, WebGPUDeviceContribution } from '@antv/g-device-api';
import { injectable } from 'inversify';
import 'reflect-metadata';
import DeviceAttribute from "./DeviceAttribute";
import DeviceBuffer from "./DeviceBuffer";
import DeviceElements from "./DeviceElements";
import DeviceFramebuffer from "./DeviceFramebuffer";
import DeviceModel from "./DeviceModel";
import DeviceTexture2D from "./DeviceTexture2D";
import { isWebGL2 } from "./utils/webgl";

/**
 * Device API renderer
 */
var DeviceRendererService = (_dec = injectable(), _dec(_class = /*#__PURE__*/function () {
  function DeviceRendererService() {
    var _this = this;
    _classCallCheck(this, DeviceRendererService);
    _defineProperty(this, "uniformBuffers", []);
    _defineProperty(this, "createModel", function (options) {
      return new DeviceModel(_this.device, options);
    });
    _defineProperty(this, "createAttribute", function (options) {
      return new DeviceAttribute(_this.device, options);
    });
    _defineProperty(this, "createBuffer", function (options) {
      return new DeviceBuffer(_this.device, options);
    });
    _defineProperty(this, "createElements", function (options) {
      return new DeviceElements(_this.device, options);
    });
    _defineProperty(this, "createTexture2D", function (options) {
      return new DeviceTexture2D(_this.device, options);
    });
    _defineProperty(this, "createFramebuffer", function (options) {
      return new DeviceFramebuffer(_this.device, options);
    });
    _defineProperty(this, "useFramebuffer", function ()
    // framebuffer: IFramebuffer | null,
    // drawCommands: () => void,
    {
      // if (framebuffer == null) {
      //   // @ts-ignore
      //   this.device.currentFramebuffer = this.device.onscreenFramebuffer;
      // } else {
      //   // @ts-ignore
      //   this.device.currentFramebuffer = framebuffer;
      // }
      // drawCommands();
    });
    _defineProperty(this, "clear", function ()
    // options: IClearOptions
    {
      // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#clear-the-draw-buffer
      // const { color, depth, stencil, framebuffer = null } = options;
      // const reglClearOptions: regl.ClearOptions = {
      //   color,
      //   depth,
      //   stencil,
      // };
      // reglClearOptions.framebuffer =
      //   framebuffer === null
      //     ? framebuffer
      //     : (framebuffer as DeviceFramebuffer).get();
      // this.gl?.clear(reglClearOptions);
      // TODO: clear
    });
    _defineProperty(this, "viewport", function (_ref) {
      var width = _ref.width,
        height = _ref.height;
      // use WebGL context directly
      // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#unsafe-escape-hatch
      // this.gl._gl.viewport(x, y, width, height);
      _this.width = width;
      _this.height = height;
      // Will be used in `setViewport` from RenderPass later.
      // @ts-ignore
      _this.device.width = width;
      // @ts-ignore
      _this.device.height = height;

      // this.gl._refresh();
    });
    _defineProperty(this, "readPixels", function ()
    // options: IReadPixelsOptions
    {
      // const { framebuffer, x, y, width, height } = options;

      // const readback = this.device.createReadback();

      // if (framebuffer) {
      //   readPixelsOptions.framebuffer = (framebuffer as DeviceFramebuffer).get();
      // }
      // return readback.readTextureSync(null, x, y, width, height, new Uint8Array()) as Uint8Array;
      return new Uint8Array();
    });
    _defineProperty(this, "getViewportSize", function () {
      // FIXME: add viewport size in Device API.
      return {
        // @ts-ignore
        width: _this.device.width,
        // @ts-ignore
        height: _this.device.height
      };
    });
    _defineProperty(this, "getContainer", function () {
      var _this$canvas;
      return (_this$canvas = _this.canvas) === null || _this$canvas === void 0 ? void 0 : _this$canvas.parentElement;
    });
    _defineProperty(this, "getCanvas", function () {
      // return this.$container?.getElementsByTagName('canvas')[0] || null;
      return _this.canvas;
    });
    _defineProperty(this, "getGLContext", function () {
      // @ts-ignore
      return _this.device['gl'];
    });
    _defineProperty(this, "destroy", function () {
      var _this$uniformBuffers;
      // this.canvas = null 清除对 webgl 实例的引用
      // @ts-ignore
      _this.canvas = null;
      (_this$uniformBuffers = _this.uniformBuffers) === null || _this$uniformBuffers === void 0 || _this$uniformBuffers.forEach(function (buffer) {
        buffer.destroy();
      });
      _this.device.destroy();

      // make sure release webgl context
      // this.gl?._gl?.getExtension('WEBGL_lose_context')?.loseContext();

      // @see https://github.com/regl-project/regl/blob/gh-pages/API.md#clean-up
      // this.gl.destroy();

      // @ts-ignore
      // this.gl = null;
    });
  }
  _createClass(DeviceRendererService, [{
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(canvas, cfg) {
        var enableWebGPU, shaderCompilerPath, deviceContribution, swapChain, gl, renderTargetTexture;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              enableWebGPU = cfg.enableWebGPU, shaderCompilerPath = cfg.shaderCompilerPath; // this.$container = $container;
              this.canvas = canvas;

              // TODO: use antialias from cfg
              deviceContribution = enableWebGPU ? new WebGPUDeviceContribution({
                shaderCompilerPath: shaderCompilerPath
              }) : new WebGLDeviceContribution({
                // Use WebGL2 first and downgrade to WebGL1 if WebGL2 is not supported.
                targets: ['webgl2', 'webgl1'],
                onContextLost: function onContextLost(e) {
                  console.warn('context lost', e);
                },
                onContextCreationError: function onContextCreationError(e) {
                  console.warn('context creation error', e);
                },
                onContextRestored: function onContextRestored(e) {
                  console.warn('context restored', e);
                }
              });
              _context.next = 5;
              return deviceContribution.createSwapChain(canvas);
            case 5:
              swapChain = _context.sent;
              swapChain.configureSwapChain(canvas.width, canvas.height);
              this.device = swapChain.getDevice();
              this.swapChain = swapChain;

              // Create default RT
              // @ts-ignore
              // this.device.onscreenFramebuffer = this.createFramebuffer({
              //   width: canvas.width,
              //   height: canvas.height,
              // });
              // // @ts-ignore
              // this.device.onscreenFramebuffer.onscreen = true;
              // // @ts-ignore
              // this.device.currentFramebuffer = this.device.onscreenFramebuffer;

              // @ts-ignore
              gl = this.device['gl'];
              this.extensionObject = {
                // @ts-ignore
                OES_texture_float: !isWebGL2(gl) && this.device['OES_texture_float']
              };
              renderTargetTexture = this.device.createTexture({
                format: Format.U8_RGBA_RT,
                width: canvas.width,
                height: canvas.height,
                usage: TextureUsage.RENDER_TARGET
              });
              this.renderTarget = this.device.createRenderTargetFromTexture(renderTargetTexture);
              this.mainDepthRT = this.device.createRenderTargetFromTexture(this.device.createTexture({
                format: Format.D24_S8,
                width: canvas.width,
                height: canvas.height,
                usage: TextureUsage.RENDER_TARGET
              }));
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function init(_x, _x2) {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "beginFrame",
    value: function beginFrame() {
      var onscreenTexture = this.swapChain.getOnscreenTexture();
      this.renderPass = this.device.createRenderPass({
        colorAttachment: [this.renderTarget],
        // colorResolveTo: [onscreen ? onscreenTexture : onscreenTexture],
        colorResolveTo: [onscreenTexture],
        colorClearColor: [TransparentBlack],
        depthStencilAttachment: this.mainDepthRT,
        depthClearValue: 1
      });
      // @ts-ignore
      this.device.renderPass = this.renderPass;
    }
  }, {
    key: "endFrame",
    value: function endFrame() {
      this.device.submitPass(this.renderPass);
    }
  }, {
    key: "getPointSizeRange",
    value: function getPointSizeRange() {
      // @ts-ignore
      var gl = this.device['gl'];
      // FIXME: implement this method in Device API.
      return gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
    }
  }, {
    key: "testExtension",
    value: function testExtension(name) {
      // OES_texture_float
      return !!this.getGLContext().getExtension(name);
    }
  }, {
    key: "setState",
    value:
    // TODO: 临时方法
    function setState() {
      // this.gl({
      //   cull: {
      //     enable: false,
      //     face: 'back',
      //   },
      //   viewport: {
      //     x: 0,
      //     y: 0,
      //     height: this.width,
      //     width: this.height,
      //   },
      //   blend: {
      //     enable: true,
      //     equation: 'add',
      //   },
      //   framebuffer: null,
      // });
      // this.gl._refresh();
    }
  }, {
    key: "setBaseState",
    value: function setBaseState() {
      // this.gl({
      //   cull: {
      //     enable: false,
      //     face: 'back',
      //   },
      //   viewport: {
      //     x: 0,
      //     y: 0,
      //     height: this.width,
      //     width: this.height,
      //   },
      //   blend: {
      //     enable: false,
      //     equation: 'add',
      //   },
      //   framebuffer: null,
      // });
      // this.gl._refresh();
    }
  }, {
    key: "setCustomLayerDefaults",
    value: function setCustomLayerDefaults() {
      // const gl = this.getGLContext();
      // gl.disable(gl.CULL_FACE);
    }
  }, {
    key: "setDirty",
    value: function setDirty(flag) {
      this.isDirty = flag;
    }
  }, {
    key: "getDirty",
    value: function getDirty() {
      return this.isDirty;
    }
  }]);
  return DeviceRendererService;
}()) || _class);
export { DeviceRendererService as default };