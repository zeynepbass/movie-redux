import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import { FilterMode, Format, MipmapFilterMode, TextureUsage } from '@antv/g-device-api';
import { gl } from '@antv/l7-core';
import { wrapModeMap } from "./constants";
export function isTexture2D(t) {
  return false;
}
var DeviceTexture2D = /*#__PURE__*/function () {
  function DeviceTexture2D(device, options) {
    _classCallCheck(this, DeviceTexture2D);
    _defineProperty(this, "isDestroy", false);
    var data = options.data,
      _options$type = options.type,
      type = _options$type === void 0 ? gl.UNSIGNED_BYTE : _options$type,
      width = options.width,
      height = options.height,
      _options$flipY = options.flipY,
      flipY = _options$flipY === void 0 ? false : _options$flipY,
      _options$format = options.format,
      format = _options$format === void 0 ? gl.RGBA : _options$format,
      _options$wrapS = options.wrapS,
      wrapS = _options$wrapS === void 0 ? gl.CLAMP_TO_EDGE : _options$wrapS,
      _options$wrapT = options.wrapT,
      wrapT = _options$wrapT === void 0 ? gl.CLAMP_TO_EDGE : _options$wrapT,
      _options$alignment = options.alignment,
      alignment = _options$alignment === void 0 ? 1 : _options$alignment;
    this.width = width;
    this.height = height;
    var pixelFormat = Format.U8_RGBA_RT;
    if (type === gl.UNSIGNED_BYTE && format === gl.RGBA) {
      pixelFormat = Format.U8_RGBA_RT;
    } else if (format === gl.LUMINANCE && type === gl.FLOAT) {
      pixelFormat = Format.F32_LUMINANCE;
    } else if (format === gl.LUMINANCE && type === gl.UNSIGNED_BYTE) {
      pixelFormat = Format.U8_LUMINANCE;
    } else {
      throw new Error("create texture error, type: ".concat(type, ", format: ").concat(format));
    }

    //   // copy pixels from current bind framebuffer
    //   x,
    //   y,
    //   copy,
    // };

    this.texture = device.createTexture({
      format: pixelFormat,
      width: width,
      height: height,
      usage: TextureUsage.SAMPLED,
      pixelStore: {
        unpackFlipY: flipY,
        packAlignment: alignment
      }
    });
    if (data) {
      // @ts-ignore
      this.texture.setImageData([data]);
    }
    this.sampler = device.createSampler({
      addressModeU: wrapModeMap[wrapS],
      addressModeV: wrapModeMap[wrapT],
      minFilter: FilterMode.POINT,
      // TODO: use mag & min
      magFilter: FilterMode.BILINEAR,
      mipmapFilter: MipmapFilterMode.NO_MIP,
      lodMinClamp: 0,
      lodMaxClamp: 0
      // maxAnisotropy: aniso,
    });
  }
  _createClass(DeviceTexture2D, [{
    key: "get",
    value: function get() {
      return this.texture;
    }
  }, {
    key: "update",
    value: function update(props) {
      var data = props.data;
      this.texture.setImageData([data]);
    }
  }, {
    key: "bind",
    value: function bind() {
      // this.texture._texture.bind();
    }
  }, {
    key: "resize",
    value: function resize(_ref) {
      var width = _ref.width,
        height = _ref.height;
      // this.texture.resize(width, height);
      this.width = width;
      this.height = height;
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return [this.width, this.height];
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.isDestroy) {
        var _this$texture;
        (_this$texture = this.texture) === null || _this$texture === void 0 || _this$texture.destroy();
      }
      this.isDestroy = true;
    }
  }]);
  return DeviceTexture2D;
}();
export { DeviceTexture2D as default };