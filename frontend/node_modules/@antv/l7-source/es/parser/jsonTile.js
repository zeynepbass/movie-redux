import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _regeneratorRuntime from "@babel/runtime/regenerator";
import { getData, getURLFromTemplate } from '@antv/l7-utils';
import VtSource from "../source/geojsonvt";
var getVectorTile = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(url, tile, requestParameters, getCustomData) {
    var params, tileUrl;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          params = {
            x: tile.x,
            y: tile.y,
            z: tile.z
          };
          tileUrl = getURLFromTemplate(url, params);
          return _context.abrupt("return", new Promise(function (resolve) {
            if (getCustomData) {
              getCustomData(params, function (err, data) {
                if (err || !data) {
                  var vectorTile = {
                    layers: {
                      defaultLayer: {
                        features: []
                      }
                    }
                  };
                  var vectorSource = new VtSource(vectorTile, tile.x, tile.y, tile.z);
                  resolve(vectorSource);
                } else {
                  var _vectorTile = {
                    layers: {
                      defaultLayer: {
                        features: data.features
                      }
                    }
                  };
                  var _vectorSource = new VtSource(_vectorTile, tile.x, tile.y, tile.z);
                  resolve(_vectorSource);
                }
              });
            } else {
              getData(_objectSpread(_objectSpread({}, requestParameters), {}, {
                url: tileUrl
              }), function (err, data) {
                if (err || !data) {
                  var vectorTile = {
                    layers: {
                      defaultLayer: {
                        features: []
                      }
                    }
                  };
                  var vectorSource = new VtSource(vectorTile, tile.x, tile.y, tile.z);
                  resolve(vectorSource);
                } else {
                  var json = JSON.parse(data);
                  var _vectorTile2 = {
                    layers: {
                      defaultLayer: {
                        features: json
                      }
                    }
                  };
                  var _vectorSource2 = new VtSource(_vectorTile2, tile.x, tile.y, tile.z);
                  resolve(_vectorSource2);
                }
              });
            }
          }));
        case 3:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function getVectorTile(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();
export default function jsonTile(url, cfg) {
  var getTileData = function getTileData(_, tile) {
    return getVectorTile(url, tile, cfg === null || cfg === void 0 ? void 0 : cfg.requestParameters, cfg.getCustomData);
  };
  var tilesetOptions = _objectSpread(_objectSpread({}, cfg), {}, {
    getTileData: getTileData
  });
  return {
    dataArray: [],
    tilesetOptions: tilesetOptions,
    isTile: true
  };
}