"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrowLineTriangulation = ArrowLineTriangulation;
exports.FlowHalfArrowFillTriangulation = FlowHalfArrowFillTriangulation;
exports.FlowLineTriangulation = FlowLineTriangulation;
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _arrow = require("./shape/arrow");
// list all arrow shape

// Half Edge
function FlowHalfArrowFillTriangulation(feature) {
  // @ts-ignore
  var coord = feature.coordinates.flat();
  var tin = 1;
  var tout = 1.0;
  return {
    vertices: [1, 0, 0].concat((0, _toConsumableArray2.default)(coord), [
    // 0
    1, 2, -3], (0, _toConsumableArray2.default)(coord), [
    // 1
    1, 1, -3], (0, _toConsumableArray2.default)(coord), [
    // 2
    0, 1, 0], (0, _toConsumableArray2.default)(coord), [
    // 3
    0, 0, 0], (0, _toConsumableArray2.default)(coord), [
    // 4
    1, 0, 0], (0, _toConsumableArray2.default)(coord), [
    // 0
    1, 2, -3], (0, _toConsumableArray2.default)(coord), [
    // 1
    1, 1, -3], (0, _toConsumableArray2.default)(coord), [
    // 2
    0, 1, 0], (0, _toConsumableArray2.default)(coord), [
    // 3
    0, 0, 0], (0, _toConsumableArray2.default)(coord)),
    normals: [-tin, 2 * tout, 1,
    // 0
    2 * tout, -tout, 1,
    // 1
    tout, -tout, 1,
    // 2
    tout, -tout, 1,
    // 3
    -tin, -tout, 1,
    // 4
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    indices: [0, 1, 2, 0, 2, 3, 0, 3, 4, 5, 6, 7, 5, 7, 8, 5, 8, 9],
    size: 7
  };
}
function FlowLineTriangulation(feature, symbolOption) {
  return symbolOption ? ArrowLineTriangulation(feature, symbolOption) : FlowHalfArrowFillTriangulation(feature);
}
function ArrowLineTriangulation(feature, symbolOption) {
  // @ts-ignore
  var coord = feature.coordinates.flat();
  var _ref = symbolOption,
    _ref$target = _ref.target,
    target = _ref$target === void 0 ? 'classic' : _ref$target,
    _ref$source = _ref.source,
    source = _ref$source === void 0 ? 'circle' : _ref$source;
  var startSymbol = shape2Vertices((0, _arrow.getSymbol)(source, 'source'), coord, 0, 0);
  var linePath = (0, _arrow.lineArrowPath)(coord, startSymbol.vertices.length / 7, symbolOption);
  var endSymbol = shape2Vertices((0, _arrow.getSymbol)(target, 'target'), coord, 1, startSymbol.vertices.length / 7 + linePath.vertices.length / 7);
  var data = {
    vertices: [].concat((0, _toConsumableArray2.default)(startSymbol.vertices), (0, _toConsumableArray2.default)(linePath.vertices), (0, _toConsumableArray2.default)(endSymbol.vertices)),
    indices: [].concat((0, _toConsumableArray2.default)(startSymbol.outLineIndices), (0, _toConsumableArray2.default)(linePath.outLineIndices), (0, _toConsumableArray2.default)(endSymbol.outLineIndices), (0, _toConsumableArray2.default)(startSymbol.indices), (0, _toConsumableArray2.default)(linePath.indices), (0, _toConsumableArray2.default)(endSymbol.indices)),
    normals: [].concat((0, _toConsumableArray2.default)(startSymbol.normals), (0, _toConsumableArray2.default)(linePath.normals), (0, _toConsumableArray2.default)(endSymbol.normals)),
    size: 7
  };
  return data;
}
// start 0,end 1;
function shape2Vertices(shape, coord) {
  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var indexOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var shapeVertices = [];
  var vertices = shape.vertices,
    indices = shape.indices,
    dimensions = shape.dimensions,
    outLineIndices = shape.outLineIndices;
  for (var i = 0; i < vertices.length; i += dimensions) {
    shapeVertices.push.apply(shapeVertices, [type, vertices[i + 1], vertices[i]].concat((0, _toConsumableArray2.default)(coord)));
  }
  return (0, _objectSpread2.default)((0, _objectSpread2.default)({}, shape), {}, {
    vertices: shapeVertices,
    indices: indices.map(function (i) {
      return i + indexOffset;
    }),
    outLineIndices: outLineIndices.map(function (i) {
      return i + indexOffset;
    })
  });
}