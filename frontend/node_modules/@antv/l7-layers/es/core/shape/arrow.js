import _typeof from "@babel/runtime/helpers/esm/typeof";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import { circle } from "./Path";
import earcut from 'earcut';
var maxArrowWidthMap = {
  circle: 2,
  triangle: 2,
  diamond: 4,
  rect: 2,
  classic: 3,
  halfTriangle: 2,
  'none': 0
};
var PathHeight = 1 / 2;
export function halfTriangleArrow(dir, options) {
  var _options$width = options.width,
    width = _options$width === void 0 ? 2 : _options$width,
    _options$height = options.height,
    height = _options$height === void 0 ? 1 : _options$height;
  return {
    vertices: [0, PathHeight * dir, 1 * dir * width, -(height + PathHeight) * dir, 1 * dir * width, (height - PathHeight) * dir, 0, PathHeight * dir, 1 * dir * width, -(height + PathHeight) * dir, 1 * dir * width, (height - PathHeight) * dir],
    indices: [3, 4, 5],
    outLineIndices: [0, 1, 2],
    normals: [1 * dir, -2 * dir, 1,
    // y,x
    -2 * dir, 1.5 * dir, 1, 1 * dir, 1.5 * dir, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    dimensions: 2
  };
}
export function triangleArrow(dir, options) {
  var _options$width2 = options.width,
    width = _options$width2 === void 0 ? 2 : _options$width2,
    _options$height2 = options.height,
    height = _options$height2 === void 0 ? 3 : _options$height2;
  return {
    vertices: [0, 0, 1 * dir * width, 1 * height, 1 * dir * width, -1 * height, 0, 0, 1 * dir * width, 1 * height, 1 * dir * width, -1 * height],
    outLineIndices: [0, 1, 2],
    indices: [3, 4, 5],
    normals: [0, -1.5 * dir, 1, 2, 1 * dir, 1, -2, 1 * dir, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    dimensions: 2
  };
}
export function rectArrow(dir, options) {
  var _options$width3 = options.width,
    width = _options$width3 === void 0 ? 2 : _options$width3,
    _options$height3 = options.height,
    height = _options$height3 === void 0 ? 2 : _options$height3;
  return {
    vertices: [0, height / 2, dir * width * 1, height / 2, dir * width * 1, -height / 2, 0, -height / 2, 0, height / 2, dir * width * 1, height / 2, dir * width * 1, -height / 2, 0, -height / 2],
    dimensions: 2,
    indices: [4, 5, 6, 4, 6, 7],
    outLineIndices: [0, 1, 2, 0, 2, 3],
    normals: [0, -dir, 1, 1, 0, 1, 0, -dir, 1, -1, -0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  };
}
export function diamondArrow(dir, options) {
  var _options$width4 = options.width,
    width = _options$width4 === void 0 ? 2 : _options$width4,
    _options$height4 = options.height,
    height = _options$height4 === void 0 ? 3 : _options$height4;
  return {
    vertices: [0, 0, 1 * width * dir, 0.5 * height, 2 * width * dir, 0, 1 * width * dir, -0.5 * height, 0, 0, 1 * width * dir, 0.5 * height, 2 * width * dir, 0, 1 * width * dir, -0.5 * height],
    dimensions: 2,
    indices: [4, 5, 6, 4, 6, 7],
    outLineIndices: [0, 1, 2, 0, 2, 3],
    normals: [0, -dir, 1, 1, 0, 1, 0, -dir, 1, -1, -0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  };
}
export function classicArrow(dir, options) {
  var _options$width5 = options.width,
    width = _options$width5 === void 0 ? 2 : _options$width5,
    _options$height5 = options.height,
    height = _options$height5 === void 0 ? 3 : _options$height5;
  return {
    vertices: [0, 0, 2 * dir * width, 1 * height, 1.5 * dir * width, 0, 2 * dir * width, -1 * height, 0, 0, 2 * dir * width, 1 * height, 1.5 * dir * width, 0, 2 * dir * width, -1 * height],
    dimensions: 2,
    indices: [4, 5, 6, 4, 6, 7],
    outLineIndices: [0, 1, 2, 0, 2, 3],
    normals: [0, -dir, 1, 1, 0, 1, 0, -dir, 1, -1, -0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  };
}
export function circleArraw(dir, options) {
  var _options$width6 = options.width,
    width = _options$width6 === void 0 ? 2 : _options$width6,
    _options$height6 = options.height,
    height = _options$height6 === void 0 ? 2 : _options$height6;
  var path = circle();
  var flattengeo = earcut.flatten([path]);
  var triangles = earcut(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);
  // @ts-ignore
  var vertice = path.map(function (t) {
    return [t[0] * width * dir, t[1] * height];
  }).flat();
  return {
    vertices: [].concat(_toConsumableArray(vertice), _toConsumableArray(vertice)),
    dimensions: 2,
    indices: triangles.map(function (v) {
      return v + path.length;
    }),
    outLineIndices: triangles,
    normals: [].concat(_toConsumableArray(path.map(function (t) {
      return [t[1] * height, t[0] * width * dir, 1];
    }).flat()), _toConsumableArray(new Array(path.length * 3).fill(0)))
  };
}
export function lineArrowPath(coord) {
  var indexOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var symbol = arguments.length > 2 ? arguments[2] : undefined;
  var sourceType = _typeof(symbol['source']) === 'object' ? symbol['source'].type : symbol['source'];
  var targetType = _typeof(symbol['target']) === 'object' ? symbol['target'].type : symbol['target'];
  var _ref = _typeof(symbol['source']) === 'object' ? symbol['source'] : {},
    _ref$width = _ref.width,
    sourceWidth = _ref$width === void 0 ? sourceType ? maxArrowWidthMap[sourceType] : 0 : _ref$width,
    _ref$height = _ref.height,
    sourceHeight = _ref$height === void 0 ? 2 : _ref$height;
  var _ref2 = _typeof(symbol['target']) === 'object' ? symbol['target'] : {},
    _ref2$width = _ref2.width,
    targetWidth = _ref2$width === void 0 ? targetType ? maxArrowWidthMap[targetType] : 0 : _ref2$width,
    _ref2$height = _ref2.height,
    targetHeight = _ref2$height === void 0 ? 2 : _ref2$height;
  return {
    vertices: [0, PathHeight, 1 * sourceWidth].concat(_toConsumableArray(coord), [1, PathHeight, -1 * targetWidth], _toConsumableArray(coord), [1, -PathHeight, -1 * targetWidth], _toConsumableArray(coord), [0, -PathHeight, 1 * sourceWidth], _toConsumableArray(coord), [0, PathHeight, 1 * sourceWidth], _toConsumableArray(coord), [1, PathHeight, -1 * targetWidth], _toConsumableArray(coord), [1, -PathHeight, -1 * targetWidth], _toConsumableArray(coord), [0, -PathHeight, 1 * sourceWidth], _toConsumableArray(coord)),
    outLineIndices: [0, 1, 2, 0, 2, 3].map(function (t) {
      return t + indexOffset;
    }),
    indices: [4, 5, 6, 4, 6, 7].map(function (t) {
      return t + indexOffset;
    }),
    normals: [1, -1, 1, 1, 1, 1, -1, 0, 1, -1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    dimensions: 2
  };
}
export function getSymbol(type, position) {
  var shape = _typeof(type) === 'object' ? type.type : type;
  var dir = position === 'source' ? 1 : -1;
  var option = _typeof(type) === 'object' ? type : {};
  switch (shape) {
    case 'circle':
      return circleArraw(dir, option);
    case 'triangle':
      return triangleArrow(dir, option);
    case 'diamond':
      return diamondArrow(dir, option);
    case 'rect':
      return rectArrow(dir, option);
    case 'classic':
      return classicArrow(dir, option);
    case 'halfTriangle':
      return halfTriangleArrow(dir, option);
    default:
      return {
        vertices: [],
        indices: [],
        normals: [],
        dimensions: 2,
        outLineIndices: [],
        outLineNormals: []
      };
  }
}