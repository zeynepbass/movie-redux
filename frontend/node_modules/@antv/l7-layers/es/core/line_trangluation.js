import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import { getSymbol, lineArrowPath } from "./shape/arrow";

// list all arrow shape

// Half Edge
export function FlowHalfArrowFillTriangulation(feature) {
  // @ts-ignore
  var coord = feature.coordinates.flat();
  var tin = 1;
  var tout = 1.0;
  return {
    vertices: [1, 0, 0].concat(_toConsumableArray(coord), [
    // 0
    1, 2, -3], _toConsumableArray(coord), [
    // 1
    1, 1, -3], _toConsumableArray(coord), [
    // 2
    0, 1, 0], _toConsumableArray(coord), [
    // 3
    0, 0, 0], _toConsumableArray(coord), [
    // 4
    1, 0, 0], _toConsumableArray(coord), [
    // 0
    1, 2, -3], _toConsumableArray(coord), [
    // 1
    1, 1, -3], _toConsumableArray(coord), [
    // 2
    0, 1, 0], _toConsumableArray(coord), [
    // 3
    0, 0, 0], _toConsumableArray(coord)),
    normals: [-tin, 2 * tout, 1,
    // 0
    2 * tout, -tout, 1,
    // 1
    tout, -tout, 1,
    // 2
    tout, -tout, 1,
    // 3
    -tin, -tout, 1,
    // 4
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    indices: [0, 1, 2, 0, 2, 3, 0, 3, 4, 5, 6, 7, 5, 7, 8, 5, 8, 9],
    size: 7
  };
}
export function FlowLineTriangulation(feature, symbolOption) {
  return symbolOption ? ArrowLineTriangulation(feature, symbolOption) : FlowHalfArrowFillTriangulation(feature);
}
export function ArrowLineTriangulation(feature, symbolOption) {
  // @ts-ignore
  var coord = feature.coordinates.flat();
  var _ref = symbolOption,
    _ref$target = _ref.target,
    target = _ref$target === void 0 ? 'classic' : _ref$target,
    _ref$source = _ref.source,
    source = _ref$source === void 0 ? 'circle' : _ref$source;
  var startSymbol = shape2Vertices(getSymbol(source, 'source'), coord, 0, 0);
  var linePath = lineArrowPath(coord, startSymbol.vertices.length / 7, symbolOption);
  var endSymbol = shape2Vertices(getSymbol(target, 'target'), coord, 1, startSymbol.vertices.length / 7 + linePath.vertices.length / 7);
  var data = {
    vertices: [].concat(_toConsumableArray(startSymbol.vertices), _toConsumableArray(linePath.vertices), _toConsumableArray(endSymbol.vertices)),
    indices: [].concat(_toConsumableArray(startSymbol.outLineIndices), _toConsumableArray(linePath.outLineIndices), _toConsumableArray(endSymbol.outLineIndices), _toConsumableArray(startSymbol.indices), _toConsumableArray(linePath.indices), _toConsumableArray(endSymbol.indices)),
    normals: [].concat(_toConsumableArray(startSymbol.normals), _toConsumableArray(linePath.normals), _toConsumableArray(endSymbol.normals)),
    size: 7
  };
  return data;
}
// start 0,end 1;
function shape2Vertices(shape, coord) {
  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var indexOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var shapeVertices = [];
  var vertices = shape.vertices,
    indices = shape.indices,
    dimensions = shape.dimensions,
    outLineIndices = shape.outLineIndices;
  for (var i = 0; i < vertices.length; i += dimensions) {
    shapeVertices.push.apply(shapeVertices, [type, vertices[i + 1], vertices[i]].concat(_toConsumableArray(coord)));
  }
  return _objectSpread(_objectSpread({}, shape), {}, {
    vertices: shapeVertices,
    indices: indices.map(function (i) {
      return i + indexOffset;
    }),
    outLineIndices: outLineIndices.map(function (i) {
      return i + indexOffset;
    })
  });
}