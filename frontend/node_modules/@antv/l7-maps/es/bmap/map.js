import _construct from "@babel/runtime/helpers/esm/construct";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _typeof from "@babel/runtime/helpers/esm/typeof";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/esm/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
var _excluded = ["id", "center", "zoom", "token", "mapInstance", "version", "mapSize", "minZoom", "maxZoom"];
import _regeneratorRuntime from "@babel/runtime/regenerator";
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
import { MapServiceEvent } from '@antv/l7-core';
import { DOM } from '@antv/l7-utils';
import { mat4, vec3 } from 'gl-matrix';
import BaseMapService from "../utils/BaseMapService";
import Viewport from "../utils/Viewport";
import { toPaddingOptions } from "../utils/utils";
import BMapGLLoader from "./bmapglloader";
function loadStyles(css, doc) {
  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== 'undefined' && wx !== null && (typeof wx.request !== 'undefined' || typeof wx.miniProgram !== 'undefined');
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc) doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName('head')[0];
  if (!head) {
    head = doc.createElement('head');
    var body = doc.body || doc.getElementsByTagName('body')[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement('style');
  style.type = 'text/css';
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles(".bmap-contianer--hide-logo .anchorBL > img[src*='api.map.baidu.com/images/logo_hd.png'] {\n  display: none;\n}\n");
var EventMap = {
  mapmove: 'moving',
  contextmenu: 'rightclick',
  camerachange: 'update',
  zoomchange: 'zoomend'
};
var BMAP_API_KEY = 'zLhopYPPERGtpGOgimcdKcCimGRyyIsh';
var BMAP_VERSION = '1.0';
var BMapService = /*#__PURE__*/function (_BaseMapService) {
  _inherits(BMapService, _BaseMapService);
  var _super = _createSuper(BMapService);
  function BMapService() {
    var _this;
    _classCallCheck(this, BMapService);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "styleConfig", {
      normal: []
    });
    _defineProperty(_assertThisInitialized(_this), "currentStyle", 'normal');
    // 事件回调代理
    _defineProperty(_assertThisInitialized(_this), "evtCbProxyMap", new Map());
    _defineProperty(_assertThisInitialized(_this), "handleCameraChanged", function () {
      _this.emit('mapchange');
      var map = _this.getMap();
      var _map$getCenter = map.getCenter(),
        lng = _map$getCenter.lng,
        lat = _map$getCenter.lat;
      var option = {
        center: [lng, lat],
        viewportHeight: map.getContainer().clientHeight,
        viewportWidth: map.getContainer().clientWidth,
        bearing: 360 - map.getHeading(),
        pitch: map.getTilt(),
        zoom: map.getZoom() - 1.75
      };
      _this.viewport.syncWithMapCamera(option);
      _this.updateCoordinateSystemService();
      _this.cameraChangedCallback(_this.viewport);
    });
    return _this;
  }
  _createClass(BMapService, [{
    key: "getMap",
    value: function getMap() {
      return this.map;
    }
  }, {
    key: "setBgColor",
    value: function setBgColor(color) {
      this.bgColor = color;
    }
  }, {
    key: "init",
    value: function () {
      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _this2 = this;
        var _this$config, id, _this$config$center, center, _this$config$zoom, zoom, _this$config$token, token, mapInstance, _this$config$version, version, _this$config$mapSize, mapSize, _this$config$minZoom, minZoom, _this$config$maxZoom, maxZoom, rest, point, mapConstructorOptions, mapContainer, mapChildNodes, map, _point;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.viewport = new Viewport();
              _this$config = this.config, id = _this$config.id, _this$config$center = _this$config.center, center = _this$config$center === void 0 ? [121.30654632240122, 31.25744185633306] : _this$config$center, _this$config$zoom = _this$config.zoom, zoom = _this$config$zoom === void 0 ? 12 : _this$config$zoom, _this$config$token = _this$config.token, token = _this$config$token === void 0 ? BMAP_API_KEY : _this$config$token, mapInstance = _this$config.mapInstance, _this$config$version = _this$config.version, version = _this$config$version === void 0 ? BMAP_VERSION : _this$config$version, _this$config$mapSize = _this$config.mapSize, mapSize = _this$config$mapSize === void 0 ? 10000 : _this$config$mapSize, _this$config$minZoom = _this$config.minZoom, minZoom = _this$config$minZoom === void 0 ? 0 : _this$config$minZoom, _this$config$maxZoom = _this$config.maxZoom, maxZoom = _this$config$maxZoom === void 0 ? 21 : _this$config$maxZoom, rest = _objectWithoutProperties(_this$config, _excluded);
              this.viewport = new Viewport();
              this.version = version;
              this.simpleMapCoord.setSize(mapSize);
              if (window.BMapGL || mapInstance) {
                _context.next = 8;
                break;
              }
              _context.next = 8;
              return BMapGLLoader.load({
                key: token,
                // 申请好的Web端开发者Key，首次调用 load 时必填
                version: BMAP_VERSION // 指定要加载的 JSAPI 的gl版本，缺省时默认为 1.0
              });
            case 8:
              if (!mapInstance) {
                _context.next = 17;
                break;
              }
              // @ts-ignore
              this.map = mapInstance;
              this.$mapContainer = this.map.getContainer();
              point = new BMapGL.Point(center[0], center[1]); // false，表示用户未执行centerAndZoom进行地图初始渲染
              // @ts-ignore
              if (!this.map.isLoaded()) {
                this.map.centerAndZoom(point, zoom + 1.75);
              }
              this.initMapByConfig(this.config);
              this.map.on('update', this.handleCameraChanged);
              _context.next = 32;
              break;
            case 17:
              mapConstructorOptions = _objectSpread({
                enableWheelZoom: true,
                minZoom: minZoom,
                maxZoom: maxZoom
              }, rest);
              if (token === BMAP_API_KEY) {
                console.warn("%c".concat(this.configService.getSceneWarninfo('MapToken'), "!"), 'color: #873bf4;font-weigh:900;font-size: 16px;');
              }
              if (id) {
                _context.next = 21;
                break;
              }
              throw Error('No container id specified');
            case 21:
              mapContainer = DOM.getContainer(id); // 存储控件等容器，百度地图实例会被卸载掉，所以实例化后需要重新挂载
              // @ts-ignore
              mapChildNodes = _toConsumableArray(mapContainer.childNodes); // @ts-ignore
              map = new BMapGL.Map(mapContainer, mapConstructorOptions);
              this.$mapContainer = map.getContainer();
              mapChildNodes.forEach(function (child) {
                _this2.$mapContainer.appendChild(child);
              });
              // @ts-ignore
              mapChildNodes = null;

              // @ts-ignore
              this.map = map;
              _point = new BMapGL.Point(center[0], center[1]);
              this.map.centerAndZoom(_point, zoom + 1.75);
              this.initMapByConfig(this.config);
              // 监听地图相机事件
              // @ts-ignore
              map.on('update', this.handleCameraChanged);
            case 32:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function init() {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "destroy",
    value: function destroy() {
      this.getMap().destroy();
    }
  }, {
    key: "onCameraChanged",
    value: function onCameraChanged(callback) {
      this.cameraChangedCallback = callback;
    }

    // tslint:disable-next-line:no-empty
  }, {
    key: "addMarkerContainer",
    value: function addMarkerContainer() {}
  }, {
    key: "getMarkerContainer",
    value: function getMarkerContainer() {
      return this.map.getPanes().markerPane;
    }

    // MapEvent // 定义事件类型
  }, {
    key: "on",
    value: function on(type, handle) {
      if (MapServiceEvent.indexOf(type) !== -1) {
        this.eventEmitter.on(type, handle);
        return;
      }
      var cbProxyMap = this.evtCbProxyMap.get(type);
      if (!cbProxyMap) {
        this.evtCbProxyMap.set(type, cbProxyMap = new Map());
      }

      // 忽略重复监听回调
      if (cbProxyMap.get(handle)) {
        return;
      }

      // 对事件对象的经纬度进行统一处理l7需要的
      var handleProxy = function handleProxy() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        if (args[0] && _typeof(args[0]) === 'object' && !args[0].lngLat && !args[0].lnglat) {
          args[0].lngLat = args[0].latlng || args[0].latLng;
        }
        handle.apply(void 0, args);
      };
      cbProxyMap.set(handle, handleProxy);
      this.map.on(EventMap[type] || type, handleProxy);
    }
  }, {
    key: "off",
    value: function off(type, handle) {
      var _this$evtCbProxyMap$g, _this$evtCbProxyMap$g2;
      if (MapServiceEvent.indexOf(type) !== -1) {
        this.eventEmitter.off(type, handle);
        return;
      }
      var handleProxy = (_this$evtCbProxyMap$g = this.evtCbProxyMap.get(type)) === null || _this$evtCbProxyMap$g === void 0 ? void 0 : _this$evtCbProxyMap$g.get(handle);
      if (!handleProxy) {
        return;
      }
      (_this$evtCbProxyMap$g2 = this.evtCbProxyMap.get(type)) === null || _this$evtCbProxyMap$g2 === void 0 || _this$evtCbProxyMap$g2.delete(handle);
      this.map.off(EventMap[type] || type, handleProxy);
    }
  }, {
    key: "once",
    value: function once(type, handler) {
      this.eventEmitter.once(type, handler);
    }
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.getMap().getContainer();
    }
  }, {
    key: "getSize",
    value: function getSize() {
      var size = this.getMap().getSize();
      return [size.width, size.height];
    }
  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      return this.map.getMinZoom() - 1.75;
    }
  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      return this.map.getMaxZoom() - 1.75;
    }

    // get map params
  }, {
    key: "getType",
    value: function getType() {
      return 'bmap';
    }
  }, {
    key: "getZoom",
    value: function getZoom() {
      return this.getMap().getZoom() - 1.75;
    }
  }, {
    key: "getCenter",
    value: function getCenter(options) {
      if (options !== null && options !== void 0 && options.padding) {
        var originCenter = this.getCenter();
        var padding = toPaddingOptions(options.padding);
        var px = this.lngLatToPixel([originCenter.lng, originCenter.lat]);
        var offsetPx = [(padding.right - padding.left) / 2, (padding.bottom - padding.top) / 2];
        var newCenter = this.pixelToLngLat([px.x - offsetPx[0], px.y - offsetPx[1]]);
        return newCenter;
      }
      var center = this.map.getCenter();
      return {
        lng: center.lng,
        lat: center.lat
      };
    }
  }, {
    key: "getPitch",
    value: function getPitch() {
      return this.getMap().getTilt();
    }
  }, {
    key: "getRotation",
    value: function getRotation() {
      return 360 - this.getMap().getHeading();
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      var bounds = this.getMap().getBounds();
      var ne = bounds.getNorthEast();
      var sw = bounds.getSouthWest();
      return [[sw.lng, sw.lat], [ne.lng, ne.lat]];
    }
  }, {
    key: "getMapContainer",
    value: function getMapContainer() {
      return this.getMap().getContainer();
    }
  }, {
    key: "getMapCanvasContainer",
    value: function getMapCanvasContainer() {
      return this.getMap().getContainer();
    }
  }, {
    key: "getMapStyleConfig",
    value: function getMapStyleConfig() {
      return this.styleConfig;
    }
  }, {
    key: "getMapStyleValue",
    value: function getMapStyleValue(name) {
      return this.styleConfig[name];
    }
  }, {
    key: "setMapStyle",
    value: function setMapStyle(style) {
      if (this.currentStyle === style) {
        return;
      }
      var styleVal = Array.isArray(style) ? style : this.styleConfig[style] || style;
      if (Array.isArray(styleVal)) {
        this.map.setMapStyleV2({
          styleJson: styleVal
        });
        this.currentStyle = style;
        return;
      }
      if (typeof styleVal === 'string') {
        this.map.setMapStyleV2({
          styleId: styleVal
        });
        this.currentStyle = style;
        return;
      }
    }
  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      this.getMap().setHeading(rotation);
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      this.getMap().zoomIn();
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      this.getMap().zoomOut();
    }
  }, {
    key: "panTo",
    value: function panTo(p) {
      this.getMap().panTo(new BMapGL.Point(p[0], p[1]));
    }
  }, {
    key: "panBy",
    value: function panBy(x, y) {
      this.getMap().panBy(x, y);
    }
  }, {
    key: "fitBounds",
    value: function fitBounds(bound, fitBoundsOptions) {
      this.map.setViewport(bound.map(function (item) {
        return new BMapGL.Point(item[0], item[1]);
      }), fitBoundsOptions);
    }
  }, {
    key: "setZoomAndCenter",
    value: function setZoomAndCenter(zoom, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        lng = _ref2[0],
        lat = _ref2[1];
      this.getMap().centerAndZoom(new BMapGL.Point(lng, lat), zoom + 1.75);
    }
  }, {
    key: "setCenter",
    value: function setCenter(_ref3, options) {
      var _ref4 = _slicedToArray(_ref3, 2),
        lng = _ref4[0],
        lat = _ref4[1];
      var newCenter = {
        lng: lng,
        lat: lat
      };
      if (options !== null && options !== void 0 && options.padding) {
        var padding = toPaddingOptions(options.padding);
        var px = this.lngLatToPixel([lng, lat]);
        var offsetPx = [(padding.right - padding.left) / 2, (padding.bottom - padding.top) / 2];
        newCenter = this.pixelToLngLat([px.x + offsetPx[0], px.y + offsetPx[1]]);
      }
      this.getMap().setCenter(new BMapGL.Point(newCenter.lng, newCenter.lat));
    }
  }, {
    key: "setPitch",
    value: function setPitch(pitch) {
      this.getMap().setTilt(pitch);
    }
  }, {
    key: "setZoom",
    value: function setZoom(zoom) {
      this.getMap().setZoom(zoom + 1.75);
    }
  }, {
    key: "setMapStatus",
    value: function setMapStatus(option) {
      var _this3 = this;
      var map = this.getMap();
      Object.keys(option).map(function (status) {
        switch (status) {
          case 'doubleClickZoom':
            option.doubleClickZoom ? map.enableDoubleClickZoom() : map.disableDoubleClickZoom();
            break;
          case 'dragEnable':
            option.dragEnable ? map.enableDragging() : map.disableDragging();
            break;
          case 'keyboardEnable':
            option.keyboardEnable ? map.enableKeyboard() : map.disableKeyboard();
            break;
          case 'resizeEnable':
            option.resizeEnable ? map.enableAutoResize() : map.disableAutoResize();
            break;
          case 'rotateEnable':
            if (option.rotateEnable) {
              map.enableRotate();
              map.enableRotateGestures();
            } else {
              map.disableRotate();
              map.disableRotateGestures();
            }
            break;
          case 'zoomEnable':
            if (option.zoomEnable) {
              _this3.map.enableDoubleClickZoom();
              _this3.map.enableScrollWheelZoom();
              _this3.map.enablePinchToZoom();
            } else {
              _this3.map.disableDoubleClickZoom();
              _this3.map.disableScrollWheelZoom();
              _this3.map.disablePinchToZoom();
            }
            break;
          case 'showIndoorMap':
            map.setDisplayOptions({
              indoor: !!option.showIndoorMap
            });
            break;
          default:
        }
      });
    }

    // coordinates methods
  }, {
    key: "meterToCoord",
    value: function meterToCoord(center, outer) {
      var metreDistance = this.getMap().getDistance(_construct(BMapGL.Point, _toConsumableArray(center)), _construct(BMapGL.Point, _toConsumableArray(outer)));
      var _this$lngLatToCoord = this.lngLatToCoord(center),
        _this$lngLatToCoord2 = _slicedToArray(_this$lngLatToCoord, 2),
        x1 = _this$lngLatToCoord2[0],
        y1 = _this$lngLatToCoord2[1];
      var _this$lngLatToCoord3 = this.lngLatToCoord(outer),
        _this$lngLatToCoord4 = _slicedToArray(_this$lngLatToCoord3, 2),
        x2 = _this$lngLatToCoord4[0],
        y2 = _this$lngLatToCoord4[1];
      var coordDistance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
      return coordDistance / metreDistance;
    }
  }, {
    key: "pixelToLngLat",
    value: function pixelToLngLat(_ref5) {
      var _ref6 = _slicedToArray(_ref5, 2),
        x = _ref6[0],
        y = _ref6[1];
      var lngLat = this.getMap().pixelToPoint(new BMapGL.Pixel(x, y));
      return {
        lng: lngLat.lng,
        lat: lngLat.lat
      };
    }
  }, {
    key: "lngLatToPixel",
    value: function lngLatToPixel(_ref7) {
      var _ref8 = _slicedToArray(_ref7, 2),
        lng = _ref8[0],
        lat = _ref8[1];
      var pixel = this.getMap().pointToPixel(new BMapGL.Point(lng, lat));
      return {
        x: pixel.x,
        y: pixel.y
      };
    }
  }, {
    key: "containerToLngLat",
    value: function containerToLngLat(_ref9) {
      var _ref10 = _slicedToArray(_ref9, 2),
        x = _ref10[0],
        y = _ref10[1];
      var point = this.getMap().overlayPixelToPoint(new BMapGL.Pixel(x, y));
      return {
        lng: point.lng,
        lat: point.lat
      };
    }
  }, {
    key: "lngLatToContainer",
    value: function lngLatToContainer(_ref11) {
      var _ref12 = _slicedToArray(_ref11, 2),
        lng = _ref12[0],
        lat = _ref12[1];
      var overlayPixel = this.getMap().pointToOverlayPixel(new BMapGL.Point(lng, lat));
      return {
        x: overlayPixel.x,
        y: overlayPixel.y
      };
    }
  }, {
    key: "lngLatToCoord",
    value: function lngLatToCoord(_ref13) {
      var _ref14 = _slicedToArray(_ref13, 2),
        lng = _ref14[0],
        lat = _ref14[1];
      var _this$getMap$pointToP = this.getMap().pointToPixel(new BMapGL.Point(lng, lat)),
        x = _this$getMap$pointToP.x,
        y = _this$getMap$pointToP.y;
      return [x, -y];
    }
  }, {
    key: "lngLatToCoords",
    value: function lngLatToCoords(list) {
      var _this4 = this;
      return list.map(function (item) {
        return Array.isArray(item[0]) ? _this4.lngLatToCoords(item) : _this4.lngLatToCoord(item);
      });
    }
  }, {
    key: "lngLatToMercator",
    value: function lngLatToMercator(_ref15, altitude) {
      var _ref16 = _slicedToArray(_ref15, 2),
        lng = _ref16[0],
        lat = _ref16[1];
      var _this$getMap$lnglatTo = this.getMap().lnglatToMercator(lng, lat),
        _this$getMap$lnglatTo2 = _slicedToArray(_this$getMap$lnglatTo, 2),
        McLng = _this$getMap$lnglatTo2[0],
        McLat = _this$getMap$lnglatTo2[1];
      return {
        x: McLng,
        y: McLat,
        z: altitude
      };
    }
  }, {
    key: "getModelMatrix",
    value: function getModelMatrix(lnglat, altitude, rotate) {
      var scale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [1, 1, 1];
      var flat = this.viewport.projectFlat(lnglat);
      var modelMatrix = mat4.create();
      mat4.translate(modelMatrix, modelMatrix, vec3.fromValues(flat[0], flat[1], altitude));
      mat4.scale(modelMatrix, modelMatrix, vec3.fromValues(scale[0], scale[1], scale[2]));
      mat4.rotateX(modelMatrix, modelMatrix, rotate[0]);
      mat4.rotateY(modelMatrix, modelMatrix, rotate[1]);
      mat4.rotateZ(modelMatrix, modelMatrix, rotate[2]);
      return modelMatrix;
    }
  }, {
    key: "getCustomCoordCenter",
    value: function getCustomCoordCenter() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "exportMap",
    value: function exportMap(type) {
      var renderCanvas = this.getMap()._webglPainter._canvas;
      var layersPng = type === 'jpg' ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL('image/jpeg') : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL('image/png');
      return layersPng;
    }
  }, {
    key: "hideLogo",
    value: function hideLogo() {
      var container = this.map.getContainer();
      if (!container) {
        return;
      }
      DOM.addClass(container, 'bmap-contianer--hide-logo');
    }
  }, {
    key: "initMapByConfig",
    value: function initMapByConfig(config) {
      var style = config.style,
        _config$pitch = config.pitch,
        pitch = _config$pitch === void 0 ? 0 : _config$pitch,
        _config$rotation = config.rotation,
        rotation = _config$rotation === void 0 ? 0 : _config$rotation,
        _config$logoVisible = config.logoVisible,
        logoVisible = _config$logoVisible === void 0 ? true : _config$logoVisible;
      if (style) {
        this.setMapStyle(style);
      }
      if (pitch) {
        this.setPitch(pitch);
      }
      if (rotation) {
        this.setRotation(rotation);
      }
      if (logoVisible === false) {
        this.hideLogo();
      }
    }
  }]);
  return BMapService;
}(BaseMapService);
export { BMapService as default };