"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));
var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread2"));
var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _l7Core = require("@antv/l7-core");
var _l7Map = require("@antv/l7-map");
var _l7Utils = require("@antv/l7-utils");
var _glMatrix = require("gl-matrix");
var _BaseMapService2 = _interopRequireDefault(require("../utils/BaseMapService"));
var _Viewport = _interopRequireDefault(require("../utils/Viewport"));
var _maploader = _interopRequireDefault(require("./maploader"));
var _excluded = ["id", "mapInstance", "center", "token", "version", "libraries", "minZoom", "maxZoom", "rotation", "pitch", "mapSize", "logoVisible"];
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function loadStyles(css, doc) {
  var isMiniAli = typeof my !== 'undefined' && !!my && typeof my.showToast === 'function' && my.isFRM !== true;
  var isWeChatMiniProgram = typeof wx !== 'undefined' && wx !== null && (typeof wx.request !== 'undefined' || typeof wx.miniProgram !== 'undefined');
  if (isMiniAli || isWeChatMiniProgram) {
    return;
  }
  if (!doc) doc = document;
  if (!doc) {
    return;
  }
  var head = doc.head || doc.getElementsByTagName('head')[0];
  if (!head) {
    head = doc.createElement('head');
    var body = doc.body || doc.getElementsByTagName('body')[0];
    if (body) {
      body.parentNode.insertBefore(head, body);
    } else {
      doc.documentElement.appendChild(head);
    }
  }
  var style = doc.createElement('style');
  style.type = 'text/css';
  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(doc.createTextNode(css));
  }
  head.appendChild(style);
  return style;
}
loadStyles(".tmap-contianer--hide-logo  img[src*='mapapi.qq.com/web/jsapi/logo/logo_def.png'] {\n  display: none;\n}\n");
var TMAP_API_KEY = 'OB4BZ-D4W3U-B7VVO-4PJWW-6TKDJ-WPB77';
var BMAP_VERSION = '1.exp';
var EventMap = {
  mapmove: 'center_changed',
  camerachange: ['drag', 'pan', 'rotate', 'pitch', 'zoom'],
  zoomchange: 'zoom',
  dragging: 'drag'
};
var TMapService = exports.default = /*#__PURE__*/function (_BaseMapService) {
  (0, _inherits2.default)(TMapService, _BaseMapService);
  var _super = _createSuper(TMapService);
  function TMapService() {
    var _this;
    (0, _classCallCheck2.default)(this, TMapService);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    // @ts-ignore
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "viewport", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "evtCbProxyMap", new Map());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleCameraChanged", function () {
      // Trigger map change event
      _this.emit('mapchange');
      // resync
      var map = _this.map;
      // @ts-ignore
      var _map$getCenter = map.getCenter(),
        lng = _map$getCenter.lng,
        lat = _map$getCenter.lat;
      var option = {
        center: [lng, lat],
        // @ts-ignore
        viewportHeight: map.getContainer().clientHeight,
        // @ts-ignore
        viewportWidth: map.getContainer().clientWidth,
        // @ts-ignore
        bearing: map.getHeading(),
        // @ts-ignore
        pitch: map.getPitch(),
        // @ts-ignore
        zoom: map.getZoom() - 1
      };
      _this.viewport.syncWithMapCamera(option);
      _this.updateCoordinateSystemService();
      _this.cameraChangedCallback(_this.viewport);
    });
    return _this;
  }
  (0, _createClass2.default)(TMapService, [{
    key: "init",
    value: function () {
      var _init = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var _this$map$controlMana;
        var _this$config, id, mapInstance, _this$config$center, center, _this$config$token, token, _this$config$version, version, _this$config$librarie, libraries, _this$config$minZoom, minZoom, _this$config$maxZoom, maxZoom, _this$config$rotation, rotation, _this$config$pitch, pitch, _this$config$mapSize, mapSize, _this$config$logoVisi, logoVisible, rest, mapContainer, map, controlParentContainer;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              this.viewport = new _Viewport.default();

              // TODO: Handle initial config
              _this$config = this.config, id = _this$config.id, mapInstance = _this$config.mapInstance, _this$config$center = _this$config.center, center = _this$config$center === void 0 ? [121.30654632240122, 31.25744185633306] : _this$config$center, _this$config$token = _this$config.token, token = _this$config$token === void 0 ? TMAP_API_KEY : _this$config$token, _this$config$version = _this$config.version, version = _this$config$version === void 0 ? BMAP_VERSION : _this$config$version, _this$config$librarie = _this$config.libraries, libraries = _this$config$librarie === void 0 ? [] : _this$config$librarie, _this$config$minZoom = _this$config.minZoom, minZoom = _this$config$minZoom === void 0 ? 3 : _this$config$minZoom, _this$config$maxZoom = _this$config.maxZoom, maxZoom = _this$config$maxZoom === void 0 ? 18 : _this$config$maxZoom, _this$config$rotation = _this$config.rotation, rotation = _this$config$rotation === void 0 ? 0 : _this$config$rotation, _this$config$pitch = _this$config.pitch, pitch = _this$config$pitch === void 0 ? 0 : _this$config$pitch, _this$config$mapSize = _this$config.mapSize, mapSize = _this$config$mapSize === void 0 ? 10000 : _this$config$mapSize, _this$config$logoVisi = _this$config.logoVisible, logoVisible = _this$config$logoVisi === void 0 ? true : _this$config$logoVisi, rest = (0, _objectWithoutProperties2.default)(_this$config, _excluded);
              if (window.TMap || mapInstance) {
                _context.next = 5;
                break;
              }
              _context.next = 5;
              return _maploader.default.load({
                key: token,
                version: version,
                libraries: libraries
              });
            case 5:
              if (!mapInstance) {
                _context.next = 11;
                break;
              }
              // If there's already a map instance, maybe not setting any other configurations
              this.map = mapInstance;
              this.$mapContainer = this.map.getContainer();
              if (logoVisible === false) {
                this.hideLogo();
              }
              _context.next = 18;
              break;
            case 11:
              if (id) {
                _context.next = 13;
                break;
              }
              throw Error('No container id specified');
            case 13:
              mapContainer = _l7Utils.DOM.getContainer(id);
              map = new TMap.Map(mapContainer, (0, _objectSpread2.default)({
                maxZoom: maxZoom,
                minZoom: minZoom,
                rotation: rotation,
                pitch: pitch,
                showControl: false,
                // Tencent use (Lat, Lng) while center is (Lng, Lat)
                center: new TMap.LatLng(center[1], center[0])
              }, rest)); // @ts-ignore
              this.map = map;
              // @ts-ignore
              this.$mapContainer = map.getContainer();
              if (logoVisible === false) {
                this.hideLogo();
              }
            case 18:
              // Set tencent map canvas element position as absolute
              // @ts-ignore
              this.map.canvasContainer.style.position = 'absolute';

              // Set tencent map control layer dom index
              // @ts-ignore
              controlParentContainer = (_this$map$controlMana = this.map.controlManager.controlContainer) === null || _this$map$controlMana === void 0 ? void 0 : _this$map$controlMana.parentNode;
              if (controlParentContainer) {
                controlParentContainer.style.zIndex = 2;
              }
              this.simpleMapCoord.setSize(mapSize);

              // May be find an integrated event replacing following events
              this.map.on('drag', this.handleCameraChanged);
              this.map.on('pan', this.handleCameraChanged);
              this.map.on('rotate', this.handleCameraChanged);
              this.map.on('pitch', this.handleCameraChanged);
              this.map.on('zoom', this.handleCameraChanged);
              this.map.on('mousemove', function () {
                return console.log('asdasd');
              });

              // Trigger camera change after init
              this.handleCameraChanged();
            case 29:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function init() {
        return _init.apply(this, arguments);
      }
      return init;
    }()
  }, {
    key: "destroy",
    value: function destroy() {
      this.map.destroy();
    }
  }, {
    key: "onCameraChanged",
    value: function onCameraChanged(callback) {
      this.cameraChangedCallback = callback;
    }
  }, {
    key: "addMarkerContainer",
    value: function addMarkerContainer() {
      var container = this.map.getContainer();
      this.markerContainer = _l7Utils.DOM.create('div', 'l7-marker-container', container);
      this.markerContainer.setAttribute('tabindex', '-1');
      this.markerContainer.style.zIndex = '2';
    }
  }, {
    key: "getMarkerContainer",
    value: function getMarkerContainer() {
      return this.markerContainer;
    }

    // MapEvent
  }, {
    key: "on",
    value: function on(type, handle) {
      var _this2 = this;
      if (_l7Core.MapServiceEvent.indexOf(type) !== -1) {
        this.eventEmitter.on(type, handle);
      } else {
        var onProxy = function onProxy(eventName) {
          var cbProxyMap = _this2.evtCbProxyMap.get(eventName);
          if (!cbProxyMap) {
            _this2.evtCbProxyMap.set(eventName, cbProxyMap = new Map());
          }
          if (cbProxyMap.get(handle)) {
            return;
          }
          var handleProxy = function handleProxy() {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            if (args[0] && (0, _typeof2.default)(args[0]) === 'object' && !args[0].lngLat && !args[0].lnglat) {
              args[0].lngLat = args[0].latlng || args[0].latLng;
            }
            handle.apply(void 0, args);
          };
          cbProxyMap.set(handle, handleProxy);
          _this2.map.on(eventName, handleProxy);
        };
        if (Array.isArray(EventMap[type])) {
          EventMap[type].forEach(function (eventName) {
            onProxy(eventName || type);
          });
        } else {
          onProxy(EventMap[type] || type);
        }
      }
    }
  }, {
    key: "off",
    value: function off(type, handle) {
      var _this3 = this;
      if (_l7Core.MapServiceEvent.indexOf(type) !== -1) {
        this.eventEmitter.off(type, handle);
        return;
      }
      var offProxy = function offProxy(eventName) {
        var _this3$evtCbProxyMap$, _this3$evtCbProxyMap$2;
        var handleProxy = (_this3$evtCbProxyMap$ = _this3.evtCbProxyMap.get(type)) === null || _this3$evtCbProxyMap$ === void 0 ? void 0 : _this3$evtCbProxyMap$.get(handle);
        if (!handleProxy) {
          return;
        }
        (_this3$evtCbProxyMap$2 = _this3.evtCbProxyMap.get(eventName)) === null || _this3$evtCbProxyMap$2 === void 0 || _this3$evtCbProxyMap$2.delete(handle);
        _this3.map.off(eventName, handleProxy);
      };
      if (Array.isArray(EventMap[type])) {
        EventMap[type].forEach(function (eventName) {
          offProxy(eventName || type);
        });
      } else {
        offProxy(EventMap[type] || type);
      }
    }
  }, {
    key: "once",
    value: function once() {
      throw new Error('Method not implemented.');
    }

    // get dom
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.map.getContainer();
    }
  }, {
    key: "getSize",
    value: function getSize() {
      // @ts-ignore
      return [this.map.width, this.map.height];
    }

    // get map status method
  }, {
    key: "getMinZoom",
    value: function getMinZoom() {
      // @ts-ignore
      return this.map.transform._minZoom;
    }
  }, {
    key: "getMaxZoom",
    value: function getMaxZoom() {
      // @ts-ignore
      return this.map.transform._maxZoom;
    }

    // get map params
  }, {
    key: "getType",
    value: function getType() {
      return 'tmap';
    }
  }, {
    key: "getZoom",
    value: function getZoom() {
      return this.map.getZoom();
    }
  }, {
    key: "getCenter",
    value: function getCenter() {
      var _this$map$getCenter = this.map.getCenter(),
        lng = _this$map$getCenter.lng,
        lat = _this$map$getCenter.lat;
      return {
        lng: lng,
        lat: lat
      };
    }
  }, {
    key: "getPitch",
    value: function getPitch() {
      return this.map.getPitch();
    }
  }, {
    key: "getRotation",
    value: function getRotation() {
      return this.map.getRotation();
    }
  }, {
    key: "getBounds",
    value: function getBounds() {
      var ne = this.map.getBounds().getNorthEast();
      var sw = this.map.getBounds().getSouthWest();
      return [[sw.lng, sw.lat], [ne.lng, ne.lat]];
    }
  }, {
    key: "getMapContainer",
    value: function getMapContainer() {
      return this.map.getContainer();
    }
  }, {
    key: "getMapCanvasContainer",
    value: function getMapCanvasContainer() {
      var _this$map$getContaine;
      return (_this$map$getContaine = this.map.getContainer()) === null || _this$map$getContaine === void 0 ? void 0 : _this$map$getContaine.getElementsByTagName('canvas')[0];
    }
  }, {
    key: "getMapStyleConfig",
    value: function getMapStyleConfig() {
      // return this.getMap()
      throw new Error('Method not implemented.');
    }
  }, {
    key: "setBgColor",
    value: function setBgColor(color) {
      this.bgColor = color;
    }
  }, {
    key: "setMapStyle",
    value: function setMapStyle(styleId) {
      this.map.setMapStyleId(styleId);
    }

    // control with raw map
  }, {
    key: "setRotation",
    value: function setRotation(rotation) {
      this.map.setRotation(rotation);
    }
  }, {
    key: "zoomIn",
    value: function zoomIn() {
      this.map.setZoom(this.getZoom() + 1);
    }
  }, {
    key: "zoomOut",
    value: function zoomOut() {
      this.map.setZoom(this.getZoom() - 1);
    }
  }, {
    key: "panTo",
    value: function panTo(_ref) {
      var _ref2 = (0, _slicedToArray2.default)(_ref, 2),
        lng = _ref2[0],
        lat = _ref2[1];
      this.map.panTo(new TMap.LatLng(lat, lng));
    }
  }, {
    key: "panBy",
    value: function panBy(x, y) {
      this.map.panBy([x, y]);
    }
  }, {
    key: "fitBounds",
    value: function fitBounds(bound, fitBoundsOptions) {
      var _bound = (0, _slicedToArray2.default)(bound, 2),
        sw = _bound[0],
        ne = _bound[1];
      var swLatLng = new TMap.LatLng(sw[1], sw[0]);
      var neLatLng = new TMap.LatLng(ne[1], ne[0]);
      var bounds = new TMap.LatLngBounds(swLatLng, neLatLng);
      // @ts-ignore
      this.map.fitBounds(bounds, fitBoundsOptions);
    }
  }, {
    key: "setZoomAndCenter",
    value: function setZoomAndCenter(zoom, _ref3) {
      var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),
        lng = _ref4[0],
        lat = _ref4[1];
      this.map.setCenter(new TMap.LatLng(lat, lng));
      this.map.setZoom(zoom);
    }
  }, {
    key: "setCenter",
    value: function setCenter(_ref5) {
      var _ref6 = (0, _slicedToArray2.default)(_ref5, 2),
        lng = _ref6[0],
        lat = _ref6[1];
      this.map.setCenter(new TMap.LatLng(lat, lng));
    }
  }, {
    key: "setPitch",
    value: function setPitch(pitch) {
      this.map.setPitch(pitch);
    }
  }, {
    key: "setZoom",
    value: function setZoom(zoom) {
      this.map.setZoom(zoom);
    }
  }, {
    key: "setMapStatus",
    value: function setMapStatus(option) {
      var _this4 = this;
      Object.keys(option).map(function (status) {
        switch (status) {
          case 'doubleClickZoom':
            _this4.map.setDoubleClickZoom(!!option.doubleClickZoom);
            break;
          case 'dragEnable':
            _this4.map.setDraggable(!!option.dragEnable);
            break;
          case 'rotateEnable':
            // @ts-ignore
            _this4.map.setRotatable(!!option.rotateEnable);
            break;
          case 'zoomEnable':
            _this4.map.setDoubleClickZoom(!!option.zoomEnable);
            _this4.map.setScrollable(!!option.zoomEnable);
            break;
          case 'keyboardEnable':
          case 'resizeEnable':
          case 'showIndoorMap':
            throw Error('Options may bot be supported');
          default:
        }
      });
    }

    // coordinates methods
  }, {
    key: "meterToCoord",
    value: function meterToCoord(_ref7, _ref8) {
      var _ref9 = (0, _slicedToArray2.default)(_ref7, 2),
        centerLon = _ref9[0],
        centerLat = _ref9[1];
      var _ref10 = (0, _slicedToArray2.default)(_ref8, 2),
        outerLon = _ref10[0],
        outerLat = _ref10[1];
      var metreDistance = TMap.geometry.computeDistance([new TMap.LatLng(centerLat, centerLon), new TMap.LatLng(outerLat, outerLon)]);
      var _ref11 = this.lngLatToCoord([centerLon, centerLat]),
        _ref12 = (0, _slicedToArray2.default)(_ref11, 2),
        x1 = _ref12[0],
        y1 = _ref12[1];
      var _ref13 = this.lngLatToCoord([outerLon, outerLat]),
        _ref14 = (0, _slicedToArray2.default)(_ref13, 2),
        x2 = _ref14[0],
        y2 = _ref14[1];
      var coordDistance = Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
      return coordDistance / metreDistance;
    }
  }, {
    key: "pixelToLngLat",
    value: function pixelToLngLat(_ref15) {
      var _ref16 = (0, _slicedToArray2.default)(_ref15, 2),
        x = _ref16[0],
        y = _ref16[1];
      // Since tecent map didn't provide the reverse method for transforming from pixel to lnglat
      // It had to be done by calculate the relative distance in container coordinates
      var _this$map$getCenter2 = this.map.getCenter(),
        clng = _this$map$getCenter2.lng,
        clat = _this$map$getCenter2.lat;
      var _this$lngLatToPixel = this.lngLatToPixel([clng, clat]),
        centerPixelX = _this$lngLatToPixel.x,
        centerPixelY = _this$lngLatToPixel.y;
      var _this$lngLatToContain = this.lngLatToContainer([clng, clat]),
        centerContainerX = _this$lngLatToContain.x,
        centerContainerY = _this$lngLatToContain.y;
      var _this$map$unprojectFr = this.map.unprojectFromContainer(new TMap.Point(centerContainerX + (x - centerPixelX), centerContainerY + (y - centerPixelY))),
        lng = _this$map$unprojectFr.lng,
        lat = _this$map$unprojectFr.lat;
      return this.containerToLngLat([lng, lat]);
    }
  }, {
    key: "lngLatToPixel",
    value: function lngLatToPixel(_ref17) {
      var _ref18 = (0, _slicedToArray2.default)(_ref17, 2),
        lng = _ref18[0],
        lat = _ref18[1];
      // @ts-ignore
      var _this$map$projectToWo = this.map.projectToWorldPlane(new TMap.LatLng(lat, lng)),
        x = _this$map$projectToWo.x,
        y = _this$map$projectToWo.y;
      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "containerToLngLat",
    value: function containerToLngLat(_ref19) {
      var _ref20 = (0, _slicedToArray2.default)(_ref19, 2),
        x = _ref20[0],
        y = _ref20[1];
      var _this$map$unprojectFr2 = this.map.unprojectFromContainer(new TMap.Point(x, y)),
        lng = _this$map$unprojectFr2.lng,
        lat = _this$map$unprojectFr2.lat;
      return {
        lng: lng,
        lat: lat
      };
    }
  }, {
    key: "lngLatToContainer",
    value: function lngLatToContainer(_ref21) {
      var _ref22 = (0, _slicedToArray2.default)(_ref21, 2),
        lng = _ref22[0],
        lat = _ref22[1];
      // @ts-ignore
      var _this$map$projectToCo = this.map.projectToContainer(new TMap.LatLng(lat, lng)),
        x = _this$map$projectToCo.x,
        y = _this$map$projectToCo.y;
      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "lngLatToCoord",
    value: function lngLatToCoord(_ref23) {
      var _ref24 = (0, _slicedToArray2.default)(_ref23, 2),
        lng = _ref24[0],
        lat = _ref24[1];
      // TODO: Perhaps need to check the three.js coordinates
      var _this$lngLatToPixel2 = this.lngLatToPixel([lng, lat]),
        x = _this$lngLatToPixel2.x,
        y = _this$lngLatToPixel2.y;
      return [x, -y];
    }
  }, {
    key: "lngLatToCoords",
    value: function lngLatToCoords(list) {
      var _this5 = this;
      return list.map(function (item) {
        return Array.isArray(item[0]) ? _this5.lngLatToCoords(item) : _this5.lngLatToCoord(item);
      });
    }
  }, {
    key: "lngLatToMercator",
    value: function lngLatToMercator(lnglat, altitude) {
      // Use built in mercator tools due to Tencent not provided related methods
      var _MercatorCoordinate$f = _l7Map.MercatorCoordinate.fromLngLat(lnglat, altitude),
        _MercatorCoordinate$f2 = _MercatorCoordinate$f.x,
        x = _MercatorCoordinate$f2 === void 0 ? 0 : _MercatorCoordinate$f2,
        _MercatorCoordinate$f3 = _MercatorCoordinate$f.y,
        y = _MercatorCoordinate$f3 === void 0 ? 0 : _MercatorCoordinate$f3,
        _MercatorCoordinate$f4 = _MercatorCoordinate$f.z,
        z = _MercatorCoordinate$f4 === void 0 ? 0 : _MercatorCoordinate$f4;
      return {
        x: x,
        y: y,
        z: z
      };
    }
  }, {
    key: "getModelMatrix",
    value: function getModelMatrix(lnglat, altitude, rotate) {
      var scale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [1, 1, 1];
      var flat = this.viewport.projectFlat(lnglat);
      // @ts-ignore
      var modelMatrix = _glMatrix.mat4.create();
      _glMatrix.mat4.translate(modelMatrix, modelMatrix, _glMatrix.vec3.fromValues(flat[0], flat[1], altitude));
      _glMatrix.mat4.scale(modelMatrix, modelMatrix, _glMatrix.vec3.fromValues(scale[0], scale[1], scale[2]));
      _glMatrix.mat4.rotateX(modelMatrix, modelMatrix, rotate[0]);
      _glMatrix.mat4.rotateY(modelMatrix, modelMatrix, rotate[1]);
      _glMatrix.mat4.rotateZ(modelMatrix, modelMatrix, rotate[2]);
      return modelMatrix;
    }
  }, {
    key: "getCustomCoordCenter",
    value: function getCustomCoordCenter() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "exportMap",
    value: function exportMap(type) {
      var renderCanvas = this.getMapCanvasContainer();
      var layersPng = type === 'jpg' ? renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL('image/jpeg') : renderCanvas === null || renderCanvas === void 0 ? void 0 : renderCanvas.toDataURL('image/png');
      return layersPng;
    }

    // Method on earth mode
  }, {
    key: "rotateY",
    value: function rotateY() {
      throw new Error('Method not implemented.');
    }
  }, {
    key: "hideLogo",
    value: function hideLogo() {
      var container = this.map.getContainer();
      if (!container) {
        return;
      }
      _l7Utils.DOM.addClass(container, 'tmap-contianer--hide-logo');
    }
  }]);
  return TMapService;
}(_BaseMapService2.default);